<!DOCTYPE html>
<!-- saved from url=(0087)http://javascript-demo.e1blue.net/demo/3d/three.js/examples/canvas_particles_random.php -->
<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<title>three.js canvas - particles - random | 3D | JavaScriptデモ</title>
<!--[if lt IE 9]><script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<style>
body {
	margin: 0;
	background-color: #000000;
	overflow: hidden;
}
</style>
<script src="jquery.min.js"></script>
<script src="three.min.js"></script>
<script src="stats.min.js"></script>
</head>
<body>
<script>
var container, stats;
var camera, scene, renderer, group, particle, particles = [], particles_origin = [], particleMax = 500, mode = 'galaxy';
var mouseX = 150, mouseY = 50;

var radius = 400;
var angle = 0;
var per = Math.PI * 2.0 / particleMax;
var locX = [], locY = [], locZ = [];
var selected_particle = [];
var easing = 1.05;

for(var i=0;i<particleMax;i++){
	selected_particle.push(i);
}

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

init();
animate();

function init() {

	$('body').append('<div id="visual" />')

	camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 4000 );
	camera.position.z = 1000;

	scene = new THREE.Scene();

	var PI2 = Math.PI * 2;
	var program = function ( context ) {

		context.beginPath();
		context.arc( 0, 0, 1, 0, PI2, true );
		context.closePath();
		context.fill();

	}

	group = new THREE.Object3D();
	scene.add( group );

	for ( var i = 0; i < particleMax; i++ ) {
		particle = new THREE.Particle( new THREE.ParticleCanvasMaterial( { color: Math.random() * 0x808008 + 0x808080, program: program } ) );

		particle.position.x = Math.random() * 3000 - 1500;
		particle.position.y = Math.random() * 3000 - 1500;
		particle.position.z = Math.random() * 2000 - 1000;
		particle.scale.x = particle.scale.y = Math.random() * 10 + 5;

		particles.push(particle);	// particleを個別に操作できるように配列に格納
		particles_origin.push({
			x: particle.position.x,
			y: particle.position.y,
			z: particle.position.z
		})
		group.add(particle);
	}

	renderer = new THREE.CanvasRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	$('#visual').append( renderer.domElement );

	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	$('#visual').append( stats.domElement );

	// 三角を作る
	var material = new THREE.MeshBasicMaterial( { color: 0xeeee00 } );
	var shape = new THREE.Shape();
	shape.moveTo(  0, 100 );
	shape.lineTo(  100, -50 );
	shape.lineTo( -100, -50 );
	shape.lineTo(  0, 100 );
	var geometry = new THREE.ShapeGeometry( shape );
	// scene.add( new THREE.Mesh( geometry, material ) );
	var triangle = new THREE.Mesh( geometry, material );
	group.add(triangle);

	document.addEventListener( 'mousemove', onDocumentMouseMove, false );
	document.addEventListener( 'touchstart', onDocumentTouchStart, false );
	document.addEventListener( 'touchmove', onDocumentTouchMove, false );

	window.addEventListener( 'resize', onWindowResize, false );

}


function onWindowResize() {

	windowHalfX = window.innerWidth / 2;
	windowHalfY = window.innerHeight / 2;

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

}

//

function onDocumentMouseMove( event ) {

	mouseX = event.clientX - windowHalfX;
	mouseY = event.clientY - windowHalfY;
}

function onDocumentTouchStart( event ) {

	if ( event.touches.length === 1 ) {

		event.preventDefault();

		mouseX = event.touches[ 0 ].pageX - windowHalfX;
		mouseY = event.touches[ 0 ].pageY - windowHalfY;

	}

}

function onDocumentTouchMove( event ) {

	if ( event.touches.length === 1 ) {

		event.preventDefault();

		mouseX = event.touches[ 0 ].pageX - windowHalfX;
		mouseY = event.touches[ 0 ].pageY - windowHalfY;

	}

}

function animate() {
	requestAnimationFrame( animate );

	render();

	stats.update();
}

function render() {
	// for(var i=0;i<particles.length;i++){

	// 	if(particles[i].position.x > 0) {
	// 		particles[i].position.x = particles[i].position.x / 1.05;
	// 	}else{
	// 		particles[i].position.x = particles[i].position.x / 1.05;
	// 	}

	// 	if(particles[i].position.y > 0) {
	// 		particles[i].position.y = particles[i].position.y / 1.05;
	// 	}else{
	// 		particles[i].position.y = particles[i].position.y / 1.05;
	// 	}

	// 	if(particles[i].position.z > 0) {
	// 		particles[i].position.z = particles[i].position.z / 1.05;
	// 	}else{
	// 		particles[i].position.z = particles[i].position.z / 1.05;
	// 	}
	// }

	// camera.position.x += ( mouseX - camera.position.x ) * 0.005;
	// camera.position.y += ( - mouseY - camera.position.y ) * 0.005;
	// camera.lookAt( scene.position );

	group.rotation.y += mouseX * 0.000005;
	group.rotation.x += mouseY * 0.000005;

	// console.log(mode);
	switch(mode){
		case 'galaxy':
			for(var i=0;i<particles.length;i++){
				particles[i].position.x = particles_origin[i].x + (particles[i].position.x - particles_origin[i].x) / easing;
				particles[i].position.y = particles_origin[i].y + (particles[i].position.y - particles_origin[i].y) / easing;
				particles[i].position.z = particles_origin[i].z + (particles[i].position.z - particles_origin[i].z) / easing;
			}
			break;
		case 'circle':
			for(var i=0;i<particleMax/2;i++){
				var key = selected_particle[i];
				particles[key].position.x = locX[key] + (particles[key].position.x - locX[key]) / easing;
				particles[key].position.y = locY[key] + (particles[key].position.y - locY[key]) / easing;
				particles[key].position.z = particles[key].position.z / easing;
			}
			break;
	}

	// group.rotation.x += ( mouseX - camera.position.x ) * 0.005;
	// group.rotation.y += ( - mouseY - camera.position.y ) * 0.0001;

	renderer.render( scene, camera );
}

$('#visual').click(function(){
	switch(mode){
		case 'galaxy':
			mode = 'circle';
			for(var i=0;i<particles.length;i++){
				locX[i] = Math.cos( angle ) * radius;
				locY[i] = Math.sin( angle ) * radius;
				locZ[i] = 0;
				angle += per;
			}

			selected_particle.sort(function(){
				return Math.random()-0.5;
			});

			// group.rotation.y = 0;
			// group.rotation.x = 0;
			break;

		case 'circle':
			mode = 'galaxy';
			break;
	}
});
</script>

<script>

</script>

</body>
</html>